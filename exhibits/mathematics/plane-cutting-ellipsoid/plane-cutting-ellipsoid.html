<!DOCTYPE html>
<html>
<head>
<title>Plane Cutting Ellipsoid</title>
<meta charset=utf-8>
<meta name=viewport content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'>
<meta name=author content=''>
<style>
	body { margin: 0px; overflow: hidden; }
  
</style>
</head>

<body>

<script src=http://rawgit.com/mrdoob/three.js/r71/build/three.min.js></script>
<script src=http://rawgit.com/mrdoob/three.js/r71/examples/js/controls/OrbitControls.js></script>

<div style='margin: .25in; position: absolute; background-color: #fdd'>
Plane Euler X: <input type=range id=eulerX min=0 max=3.14 step=0.01 value=2.4 oninput='plane.rotation.x = eulerX.value'/><br/>
Plane Euler Y: <input type=range id=eulerY min=0 max=3.14 step=0.01 value=0.9 oninput='plane.rotation.y = eulerY.value'/><br/>
<input type=button value='Toggle ellipse' onclick='ellipsoid.visible = !ellipsoid.visible'/>
<input type=button value='Toggle axes' onclick='axes.visible = !axes.visible'/><br/>
Scale X: <input type=range id=scaleX min=1 max=3 step=0.01 value=1 oninput='ellipsoid.scale.x = scaleX.value'/><br/>
Scale Y: <input type=range id=scaleY min=1 max=3 step=0.01 value=1.7 oninput='ellipsoid.scale.y = scaleY.value'/><br/>
Scale Z: <input type=range id=scaleZ min=1 max=3 step=0.01 value=1 oninput='ellipsoid.scale.z = scaleZ.value'/>
</div>

<script>

	var scene = new THREE.Scene();
	var renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setClearColor( 0xffffff );
	document.body.appendChild( renderer.domElement ); 
	
	var axes = new THREE.AxisHelper( 2 );
	scene.add( axes );
	
	var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); 
	camera.up.set( 0, 0, 1 );
	camera.position.set( 2, 2, 2 ); 
	var controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	var planeGeometry = new THREE.PlaneGeometry( 5, 5 );
	var plane = new THREE.Mesh( planeGeometry, new THREE.MeshBasicMaterial( { color: 0x000000, side: THREE.DoubleSide } ) );
	plane.rotation.x = eulerX.value;
	plane.rotation.y = eulerY.value;
	scene.add( plane );

	window.addEventListener( 'resize', function() {
		
		renderer.setSize( window.innerWidth, window.innerHeight );
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		
	} );
	
	var ellipsoidGeometry = new THREE.SphereGeometry( 1, 100, 50 );
	var ellipsoid = new THREE.Mesh( ellipsoidGeometry, new THREE.MeshNormalMaterial() );
	ellipsoid.scale.x = scaleX.value;
	ellipsoid.scale.y = scaleY.value;
	ellipsoid.scale.z = scaleZ.value;
	scene.add( ellipsoid );
	
	/* Ellipsoid parametrization:
	
		( scaleX * x )^2 + ( scaleY * y )^2 + ( scaleZ * z )^2 = 1
		
	   Normal to plane is z-axis rotated by eulerX and eulerY
	   Plane parametrization:
	   
		n.x * x + n.y * y + n.z * z = 0
	
	   Intersection is quadratic equation
	   
	   	a * y^2 + 2 * b * x * y + c * x^2 - 1 = 0
	   
	   formed by elimnating z-variable */
	   
	function findCut() {
		
		var n = new THREE.Vector3( 0, 0, 1 );
		n.applyAxisAngle( new THREE.Vector3( 1, 0, 0 ), eulerX.value );
		n.applyAxisAngle( new THREE.Vector3( 0, 1, 0 ), eulerY.value );

		var a = Math.pow( scaleY.value, 2 ) + Math.pow( scaleZ.value, 2 ) * n.y * n.y / n.z / n.z;
		var b = Math.pow( scaleZ.value, 2 ) * n.x * n.y / n.z / n.z;
		var c = Math.pow( scaleX.value, 2 ) + Math.pow( scaleZ.value, 2 ) * n.x * n.x / n.z / n.z;
		
		var vertexPlus = [], vertexMinus = [];
		
		var limit = Math.sqrt( a * c / ( a * c - b * b ) );
		for ( var i = -limit ; i <= limit ; i += .01 ) {
			
			j = ( -b * i + Math.sqrt( i * i * ( b * b - a * c) + a ) ) / a;
			k = -( n.x * i + n.y * j ) / n.z
			vertexPlus.push( new THREE.Vector3( i, j, k ) )

			j = ( -b * i - Math.sqrt( i * i * ( b * b - a * c) + a ) ) / a;
			k = -( n.x * i + n.y * j ) / n.z
			vertexMinus.push( new THREE.Vector3( i, j, k ) )

		}
		
		var v = vertexPlus.concat( vertexMinus );
		var geometry = new THREE.Geometry();
		for ( var i = 0 ; i < v.length ; i++ ) {
			
			geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
			geometry.vertices.push( v[i] );
			geometry.vertices.push( v[i+1] );
			
			var l = geometry.vertices.length;
			geometry.faces.push( geometry.vertices[l-3], geometry.vertices[l-2], geometry.vertices[l-1] );
			
		}
		
		return geometry;
		
	}

	function render() {
		
		requestAnimationFrame( render ); 
		renderer.render( scene, camera );
		controls.update();
		
		scene.remove( cutting );
		var cutting = new THREE.Mesh( findCut(), new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide } ) );
		scene.add( cutting );
		
	}
	
	render();
</script>

</body>
</html>
